package schema

import (
	"database/sql"
	"fmt"
	"os"

	_ "github.com/mattn/go-sqlite3" // For opening the in-memory database
)

// DotGo writes '<filename>' in the current directory, containing SQL statements that match the given schema updates.
//
// The <filename> contains a "flattened" render of all given updates and
// can be used to initialize brand new databases using Schema.Fresh().
func DotGo(updates map[int]Update, pkg string, filename string) error {
	// Apply all the updates that we have on a pristine database and dump
	// the resulting schema.
	db, err := sql.Open("sqlite3", ":memory:")
	if err != nil {
		return fmt.Errorf("failed to open in-memory SQLite database: %w", err)
	}

	schema := NewFromMap(updates)

	_, err = schema.Ensure(db)
	if err != nil {
		return err
	}

	dump, err := schema.Dump(db)
	if err != nil {
		return err
	}

	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to open Go file for writing: %w", err)
	}

	_, err = fmt.Fprintf(file, dotGoTemplate, pkg, dump)
	if err != nil {
		return fmt.Errorf("failed to write to Go file: %w", err)
	}

	return nil
}

// Template for schema files (can't use backticks since we need to use backticks
// inside the template itself).
const dotGoTemplate = "package %s\n\n" +
	"// DO NOT EDIT BY HAND\n" +
	"//\n" +
	"// This code was generated by the schema.DotGo function. If you need to\n" +
	"// modify the database schema, please add a new schema update to update.go\n" +
	"// and the run 'make update-schema'.\n" +
	"const freshSchema = `\n" +
	"%s`\n"
